#! /usr/bin/env node --harmony

var program = require('commander');
var debug = require('debug')('gaia-taskcluster:worker-cli');
var co = require('co');
var createRuntime = require('../lib/runtime');
var taskcluster = require('taskcluster-client');

var Status = require('../lib/treeherder/status');
var Listener = taskcluster.Listener;
var TreeherderRepo = require('mozilla-treeherder/project');

var queueEvents = new taskcluster.QueueEvents();
var schedulerEvents = new taskcluster.SchedulerEvents();

program.usage(
  '[options]\n\n' +
  'Note that if no queue name is given the queue will not be durable\n'
);

program.parse(process.argv);

function jobFromTask(runtime, taskState) {
  var state = taskState.status.state;
  switch (state) {
    case 'pending':
    case 'running':
    case 'failed':
    case 'completed':
      return Status[state](runtime, taskState);
    default:
      runtime.log(
        'unknown task status', { name: state, payload: taskState  }
      );
      return Promise.resolve();
  }
}

co(function*() {
  var profile = program.args[0];
  if (!profile) {
    console.error('Profile must be passed <production|test>');
    return process.exit(1);
  }

  var runtime = yield createRuntime(require('../config/' + profile));
  var amqpUri = runtime.taskcluster.listener.connectionString ||
                (yield runtime.queue.getAMQPConnectionString());

  runtime.taskcluster.listener.connectionString = amqpUri;
  runtime.listener = new Listener(runtime.taskcluster.listener);

  var routingKey = 'route.' + runtime.route;

  yield [
    runtime.listener.bind(queueEvents.taskPending(routingKey)),
    runtime.listener.bind(queueEvents.taskRunning(routingKey)),
    runtime.listener.bind(queueEvents.taskCompleted(routingKey)),
    runtime.listener.bind(queueEvents.taskFailed(routingKey))
  ];

  var channel = yield runtime.listener.connect();
  channel.consume(runtime.listener._queueName, co(function* (msg) {
    try {
      var content = JSON.parse(msg.content);
      runtime.log('worker handle message', { message: content });
      var job = yield jobFromTask(runtime, content);
      var project = yield runtime.projects.findByName(job.project || 'gaia');

      var treeherderRepo = new TreeherderRepo(project.name, {
        consumerKey: project.consumerKey,
        consumerSecret: project.consumerSecret,
        baseUrl: runtime.treeherder.baseUrl
      });
      runtime.log('post job', { job: job });
      yield treeherderRepo.postJobs([job]);
      channel.ack(msg);
    } catch (e) {
      runtime.log('worker consume error', { message: e.message, err: e });
      channel.nack(msg); // this will retry the message...
    }
  }));
})(function(err) {
  if (!err) return;
  throw err;
});
